build_arch = "64"
if eq(get_platform(), windows) {
    target_exec = "Electron.exe"
    dylib_prefix = ".dll"
    dylib_id = ""
    object_add_link_options(mwindows)
} else {
    target_exec = "Electron"
    dylib_prefix = ".so"
    dylib_id = "lib"
}

load_module("scripts/electron_build_utils.py")

std_cxx = "20"

object_add_link_options(m64)

impl_target_file = null

object_add_compile_options(fPIC)
object_add_compile_options(g) # include debug symbols
object_add_compile_options("I /usr/include/")

dump_compilation_commands(0)

target_impls = [
    project_configuration_impl,
    render_preview_impl,
    layer_properties_impl,
    asset_manager_impl
]

target_layers = [
    sdf2d_layer
]

scenario build_core {
    info("starting Electron build")
    object_add_compile_definition("GLEW_STATIC")
    compilation_targets = cat(glob_files("src", "cpp"), glob_files("src", "c"))
    compilation_targets = filter_list_from_string($compilation_targets, "clip")
    list_append($compilation_targets, "src/clip.cpp")
    if eq(get_platform(), windows) {
        list_append($compilation_targets, "src/clip_win.cpp")
    } else {
        list_append($compilation_targets, "src/clip_x11.cpp")
    }
    objects = object_compile(
        $compilation_targets,
        $build_arch
    )

    deps = list()
    if eq(get_platform(), windows) {
        list_append($deps, opengl32)
        list_append($deps, glfw3)
        deps = [
            opengl32, glfw3, windowscodecs, ole32, shlwapi, pthread, dbgeng, backtrace, dbgeng, bfd, dbghelp
        ]
    } else {
        deps = [
            glut, glfw, GL, GLU, m, Xrandr, Xi, X11, pthread, "stdc++", dl, pthread, backtrace, bfd, xcb
        ]
    }

    if eq(get_platform(), windows) {
        object_add_link_options(static)
        object_add_link_options("static-libstdc++")
    } else {
        object_add_link_options("rdynamic")
    }
    link_executable($objects, $target_exec, $deps)
}

scenario build_impl {
    info(cat("compiling impl ", $impl_target_file))

    shared_library_name = cat($dylib_id, cat($impl_target_file, $dylib_prefix))
    object_set_include_path("src/")
    impl_objects = object_compile(cat(cat("impl/", $impl_target_file), ".cpp"), $build_arch)

    impl_deps = list()
    if eq(get_platform(), windows) {
        impl_deps = [
            opengl32, glfw3, pthread, dbgeng, backtrace, bfd, dbghelp
        ]
    } else {
        impl_deps = [
            "stdc++", dl, pthread, backtrace, bfd, dl
        ]
    }
    link_executable($impl_objects, $shared_library_name, $impl_deps, shared)
}

scenario build_layer {
    call_scenario(build_impl)
    mv(cat($dylib_id, cat($impl_target_file, $dylib_prefix)), cat("layers/", cat($dylib_id, cat($impl_target_file, $dylib_prefix))))
}

scenario clean {
    if path_exists($target_exec) {
        rm($target_exec) 
    }
    if path_exists("layers/") {
        rmtree("layers")
    }

    mkdir("layers")
    object_clean()

    for_each($target_impls, shared_lib_name, clean_shared_library)
}

scenario clean_shared_library {
    rm_path = cat($shared_lib_name, $dylib_prefix)
    if path_exists($rm_path) {
        rm($rm_path)
    }
}

scenario build {
    if path_exists($target_exec) {
        rm($target_exec)
    }
    call_scenario(generate_headers)
    call_scenario(build_core)

    if not(path_exists("layers/")) {
        mkdir("layers")
    }

    object_add_compile_definition(ELECTRON_IMPLEMENTATION_MODE)
    for_each($target_impls, impl_target_file, execute_build_impl)
    for_each($target_layers, impl_target_file, execute_build_layer)
}

scenario execute_build_impl {
    call_scenario(build_impl)
}

scenario execute_build_layer {
    call_scenario(build_layer)
}

scenario generate_headers {
    subprocess_run([python, "scripts/generate_ui_core_header.py", "src/ui_core.h"])
    subprocess_run([python, "scripts/generate_ui_api.py", "src/ui_api.h"])
}

default_scenario = build