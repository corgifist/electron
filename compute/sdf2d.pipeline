#vertex

layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aUV;

out vec2 vPos;
out vec2 vUV;

uniform mat4 uTransform;
uniform mat4 uProjection;

void main() {
    gl_Position = uProjection * uTransform * vec4(vec3(aPos, 0.0), 1.0);
    vPos = aPos;
    vUV = aUV;
}
#fragment

layout(location = 0) out vec4 gColor;
layout(location = 1) out vec4 gUV;
layout(location = 2) out vec4 gDepth;

in vec2 vPos;
in vec2 vUV;

uniform vec3 uColor;
uniform int uCanTexture;
uniform sampler2D uTexture;

#define SDF_SHAPE_NONE 0
#define SDF_SHAPE_CIRCLE 1
#define SDF_SHAPE_ROUNDED_RECT 2

uniform int uSdfShape;

uniform float uSdfCircleRadius;
uniform vec2 uSize;

float sdfCircle(vec2 uv, float r) {
    return length(uv) - r;
}

float sdfRoundedBox(vec2 position, vec2 halfSize, float cornerRadius) {
   position = abs(position) - halfSize + cornerRadius;
   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;
}


void main() {
    gColor = vec4(uColor, 1.0);
    if (uCanTexture == 1) {
        gColor *= texture(uTexture, vUV);
    }
    if (uSdfShape != SDF_SHAPE_NONE) {
        float d = 0.0;
        if (uSdfShape == SDF_SHAPE_CIRCLE) {
            d = sdfCircle(vUV - 0.5, uSdfCircleRadius);
        }
        if (uSdfShape == SDF_SHAPE_ROUNDED_RECT) {
            d = sdfRoundedBox(vUV - 0.5, uSize, uSdfCircleRadius);
        }
        if (d > 0.0) {
            gColor *= 0.0;
        }
    }
    gUV = vec4(vUV, 0.0, 1.0);
    gDepth = vec4(0.0, 0.0, 0.0, 0.0);
}